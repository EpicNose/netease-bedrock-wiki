---
front:
hard: 入门
time: 10分钟
---


# 命令

## 了解命令

首先我们先对一个命令进行拆解 `/taboolib give <user>`
* `主节点: /taboolib`
* `子节点：/give`
* `参数层：<user>`

了解完以后我们创建命令
```kotlin
@CommandHeader("taboolib", ["tl"], permission = "taboolib.command")
object TestCommand {

    // 子节点
    @CommandBody
    val give = subCommand {
        // 参数 user
        dynamic("user") {
            execute<CommandSender> { sender, context, argument ->
                // 获取参数的值
                val user = context["user"]
                sender.sendMessage("Hello, ${user}")
            }
        }
    }
}
```
这样我们就创建了一个`/taboolib`的主命令，子命令是`give`，参数层是填写`玩家名`的命令了

## 参数类型
我们还可以根据实际情况对参数的类型进行限制和选择
1. String类型
```kotlin
dynamic("user") {
    execute<CommandSender> { sender, context, argument ->
        val user = context["user"]
        sender.sendMessage("Hello, ${user}")
    }
}
```
2. Int类型
```kotlin
int("amount") {
    execute<CommandSender> { sender, context, argument ->
        val amount = context.int("amount")
        sender.sendMessage("Hello, ${amount}")
    }
}
```
3. Double 类型
```kotlin
decimal("amount") {
    execute<CommandSender> { sender, context, argument ->
        val amount = context.double("amount")
        sender.sendMessage("Hello, ${amount}")
    }
}
```
4. Player类型
```kotlin
player("user") {
    execute<CommandSender> { sender, context, argument ->
        val user = context.player("user")
        // 转化为Bukkit的Player
        val bukkitPlayer = user.castSafely<Player>()
        sender.sendMessage("Hello, ${user}")
    }
}
```
5. Boolean类型
```kotlin
bool("选项"){
    execute<Player> { sender, context, argument ->
        UI.open(sender, xxx, context.bool("选项"))
    }
}
```

## 节点忽略
面对命令 /taboolib give xxx 的时候 我想实现
1. 有xxx的时候给xxx发消息
2. 没有xxx的时候给指令执行者发消息  

我应该如何写呢？

```kotlin
@CommandBody
val give = subCommand {
    dynamic("user") {
        execute<CommandSender> { sender, context, argument ->
            val user = context["user"]
            sender.sendMessage("Hello, ${user}")
        }
    }
    execute<CommandSender> { sender, context, argument ->
        sender.sendMessage("Hello, MySelf")
    }
}
```

在没有接受到参数 user的时候就不再执行 user方法体内的函数了 执行下方的函数


## 参数补全
假如你有一个商店插件 你要对商店名进行补全 如何书写呢?
```kotlin
@CommandBody(permission = "shop.open")
val open = subCommand {
    dynamic("商店名") {
        suggestion<CommandSender>(uncheck = true) { sender, context ->
            ShopManager.getShopNameList()
        }
        player("目标玩家") {
            execute<CommandSender> { sender, context, argument ->
                Bukkit.getPlayer(context.player("目标玩家").uniqueId)
                    ?.let { UIShopInfo.open(it, context["商店名"]) }
            }
        }
        execute<Player> { sender, context, argument ->
            UIShopInfo.open(sender, context["商店名"])
        }
    }
}
```
我们注意到在参数节点下方的 `suggestion` 方法
```kotlin
suggestion<CommandSender>(uncheck = true) { sender, context ->
    ShopManager.getShopNameList()
}
```
我们需要在这个环节 返回一个`List<String>` 然后就可以进行补全了
如果只想作为提示不想强行约束需要标记 (uncheck = true)

## 注册简单命令

如果想要注册一个 `/day` 的指令如何快速注册呢？  
这里利用到了 [自唤醒](4-自唤醒.md) 功能
```kotlin
@Awake(LifeCycle.ENABLE)
fun test() {
    simpleCommand("day") { sender, args ->
        Bukkit.getWorld("world")?.time = 1000
    }
}
```
我们就在服务器 Enable 环节进行注册命令